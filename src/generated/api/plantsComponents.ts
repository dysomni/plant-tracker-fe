/**
 * Generated by @openapi-codegen
 *
 * @version 0.1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { usePlantsContext, PlantsContext } from "./plantsContext";
import type * as Fetcher from "./plantsFetcher";
import { plantsFetch } from "./plantsFetcher";
import type * as Schemas from "./plantsSchemas";

export type ListAllPlantsV1PlantsGetQueryParams = {
  /**
   * @default false
   */
  include_archived?: boolean;
};

export type ListAllPlantsV1PlantsGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ListAllPlantsV1PlantsGetVariables = {
  queryParams?: ListAllPlantsV1PlantsGetQueryParams;
} & PlantsContext["fetcherOptions"];

export const fetchListAllPlantsV1PlantsGet = (
  variables: ListAllPlantsV1PlantsGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.ListPlantsResponseModel,
    ListAllPlantsV1PlantsGetError,
    undefined,
    {},
    ListAllPlantsV1PlantsGetQueryParams,
    {}
  >({ url: "/v1/plants", method: "get", ...variables, signal });

export const useListAllPlantsV1PlantsGet = <
  TData = Schemas.ListPlantsResponseModel,
>(
  variables: ListAllPlantsV1PlantsGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ListPlantsResponseModel,
      ListAllPlantsV1PlantsGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<
    Schemas.ListPlantsResponseModel,
    ListAllPlantsV1PlantsGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/v1/plants",
      operationId: "listAllPlantsV1PlantsGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListAllPlantsV1PlantsGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type CreatePlantV1PlantsPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreatePlantV1PlantsPostVariables = {
  body: Schemas.CreatePlantRequest;
} & PlantsContext["fetcherOptions"];

export const fetchCreatePlantV1PlantsPost = (
  variables: CreatePlantV1PlantsPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.FullPlantInfoResponseModel,
    CreatePlantV1PlantsPostError,
    Schemas.CreatePlantRequest,
    {},
    {},
    {}
  >({ url: "/v1/plants", method: "post", ...variables, signal });

export const useCreatePlantV1PlantsPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FullPlantInfoResponseModel,
      CreatePlantV1PlantsPostError,
      CreatePlantV1PlantsPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.FullPlantInfoResponseModel,
    CreatePlantV1PlantsPostError,
    CreatePlantV1PlantsPostVariables
  >({
    mutationFn: (variables: CreatePlantV1PlantsPostVariables) =>
      fetchCreatePlantV1PlantsPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPlantV1PlantsPlantIdGetPathParams = {
  plantId: string;
};

export type GetPlantV1PlantsPlantIdGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type GetPlantV1PlantsPlantIdGetVariables = {
  pathParams: GetPlantV1PlantsPlantIdGetPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchGetPlantV1PlantsPlantIdGet = (
  variables: GetPlantV1PlantsPlantIdGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.FullPlantInfoResponseModel,
    GetPlantV1PlantsPlantIdGetError,
    undefined,
    {},
    {},
    GetPlantV1PlantsPlantIdGetPathParams
  >({ url: "/v1/plants/{plantId}", method: "get", ...variables, signal });

export const useGetPlantV1PlantsPlantIdGet = <
  TData = Schemas.FullPlantInfoResponseModel,
>(
  variables: GetPlantV1PlantsPlantIdGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FullPlantInfoResponseModel,
      GetPlantV1PlantsPlantIdGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<
    Schemas.FullPlantInfoResponseModel,
    GetPlantV1PlantsPlantIdGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/v1/plants/{plantId}",
      operationId: "getPlantV1PlantsPlantIdGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPlantV1PlantsPlantIdGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type UpdatePlantV1PlantsPlantIdPatchPathParams = {
  plantId: string;
};

export type UpdatePlantV1PlantsPlantIdPatchError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type UpdatePlantV1PlantsPlantIdPatchVariables = {
  body?: Schemas.UpdatePlantRequest;
  pathParams: UpdatePlantV1PlantsPlantIdPatchPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchUpdatePlantV1PlantsPlantIdPatch = (
  variables: UpdatePlantV1PlantsPlantIdPatchVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.FullPlantInfoResponseModel,
    UpdatePlantV1PlantsPlantIdPatchError,
    Schemas.UpdatePlantRequest,
    {},
    {},
    UpdatePlantV1PlantsPlantIdPatchPathParams
  >({ url: "/v1/plants/{plantId}", method: "patch", ...variables, signal });

export const useUpdatePlantV1PlantsPlantIdPatch = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FullPlantInfoResponseModel,
      UpdatePlantV1PlantsPlantIdPatchError,
      UpdatePlantV1PlantsPlantIdPatchVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.FullPlantInfoResponseModel,
    UpdatePlantV1PlantsPlantIdPatchError,
    UpdatePlantV1PlantsPlantIdPatchVariables
  >({
    mutationFn: (variables: UpdatePlantV1PlantsPlantIdPatchVariables) =>
      fetchUpdatePlantV1PlantsPlantIdPatch({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type GetPlantPhotosV1PlantsPlantIdPhotosGetPathParams = {
  plantId: string;
};

export type GetPlantPhotosV1PlantsPlantIdPhotosGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type GetPlantPhotosV1PlantsPlantIdPhotosGetVariables = {
  pathParams: GetPlantPhotosV1PlantsPlantIdPhotosGetPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchGetPlantPhotosV1PlantsPlantIdPhotosGet = (
  variables: GetPlantPhotosV1PlantsPlantIdPhotosGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.PlantPhotosResponseModel,
    GetPlantPhotosV1PlantsPlantIdPhotosGetError,
    undefined,
    {},
    {},
    GetPlantPhotosV1PlantsPlantIdPhotosGetPathParams
  >({
    url: "/v1/plants/{plantId}/photos",
    method: "get",
    ...variables,
    signal,
  });

export const useGetPlantPhotosV1PlantsPlantIdPhotosGet = <
  TData = Schemas.PlantPhotosResponseModel,
>(
  variables: GetPlantPhotosV1PlantsPlantIdPhotosGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PlantPhotosResponseModel,
      GetPlantPhotosV1PlantsPlantIdPhotosGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<
    Schemas.PlantPhotosResponseModel,
    GetPlantPhotosV1PlantsPlantIdPhotosGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/v1/plants/{plantId}/photos",
      operationId: "getPlantPhotosV1PlantsPlantIdPhotosGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetPlantPhotosV1PlantsPlantIdPhotosGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type WaterPlantV1PlantsPlantIdWaterPostPathParams = {
  plantId: string;
};

export type WaterPlantV1PlantsPlantIdWaterPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type WaterPlantV1PlantsPlantIdWaterPostVariables = {
  body: Schemas.CreateWateringRequest;
  pathParams: WaterPlantV1PlantsPlantIdWaterPostPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchWaterPlantV1PlantsPlantIdWaterPost = (
  variables: WaterPlantV1PlantsPlantIdWaterPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.FullPlantInfoResponseModel,
    WaterPlantV1PlantsPlantIdWaterPostError,
    Schemas.CreateWateringRequest,
    {},
    {},
    WaterPlantV1PlantsPlantIdWaterPostPathParams
  >({
    url: "/v1/plants/{plantId}/water",
    method: "post",
    ...variables,
    signal,
  });

export const useWaterPlantV1PlantsPlantIdWaterPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FullPlantInfoResponseModel,
      WaterPlantV1PlantsPlantIdWaterPostError,
      WaterPlantV1PlantsPlantIdWaterPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.FullPlantInfoResponseModel,
    WaterPlantV1PlantsPlantIdWaterPostError,
    WaterPlantV1PlantsPlantIdWaterPostVariables
  >({
    mutationFn: (variables: WaterPlantV1PlantsPlantIdWaterPostVariables) =>
      fetchWaterPlantV1PlantsPlantIdWaterPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type CheckPlantV1PlantsPlantIdCheckPostPathParams = {
  plantId: string;
};

export type CheckPlantV1PlantsPlantIdCheckPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CheckPlantV1PlantsPlantIdCheckPostVariables = {
  body: Schemas.CreateCheckRequest;
  pathParams: CheckPlantV1PlantsPlantIdCheckPostPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchCheckPlantV1PlantsPlantIdCheckPost = (
  variables: CheckPlantV1PlantsPlantIdCheckPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.FullPlantInfoResponseModel,
    CheckPlantV1PlantsPlantIdCheckPostError,
    Schemas.CreateCheckRequest,
    {},
    {},
    CheckPlantV1PlantsPlantIdCheckPostPathParams
  >({
    url: "/v1/plants/{plantId}/check",
    method: "post",
    ...variables,
    signal,
  });

export const useCheckPlantV1PlantsPlantIdCheckPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FullPlantInfoResponseModel,
      CheckPlantV1PlantsPlantIdCheckPostError,
      CheckPlantV1PlantsPlantIdCheckPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.FullPlantInfoResponseModel,
    CheckPlantV1PlantsPlantIdCheckPostError,
    CheckPlantV1PlantsPlantIdCheckPostVariables
  >({
    mutationFn: (variables: CheckPlantV1PlantsPlantIdCheckPostVariables) =>
      fetchCheckPlantV1PlantsPlantIdCheckPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type GetOutstandingRemindersV1RemindersOutstandingGetError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type GetOutstandingRemindersV1RemindersOutstandingGetVariables =
  PlantsContext["fetcherOptions"];

export const fetchGetOutstandingRemindersV1RemindersOutstandingGet = (
  variables: GetOutstandingRemindersV1RemindersOutstandingGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.OutstandingRemindersResponseModel,
    GetOutstandingRemindersV1RemindersOutstandingGetError,
    undefined,
    {},
    {},
    {}
  >({ url: "/v1/reminders/outstanding", method: "get", ...variables, signal });

export const useGetOutstandingRemindersV1RemindersOutstandingGet = <
  TData = Schemas.OutstandingRemindersResponseModel,
>(
  variables: GetOutstandingRemindersV1RemindersOutstandingGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OutstandingRemindersResponseModel,
      GetOutstandingRemindersV1RemindersOutstandingGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<
    Schemas.OutstandingRemindersResponseModel,
    GetOutstandingRemindersV1RemindersOutstandingGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/v1/reminders/outstanding",
      operationId: "getOutstandingRemindersV1RemindersOutstandingGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchGetOutstandingRemindersV1RemindersOutstandingGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type CreateReminderV1RemindersPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateReminderV1RemindersPostVariables = {
  body: Schemas.CreateReminderRequest;
} & PlantsContext["fetcherOptions"];

export const fetchCreateReminderV1RemindersPost = (
  variables: CreateReminderV1RemindersPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.ReminderWithPlantInfo,
    CreateReminderV1RemindersPostError,
    Schemas.CreateReminderRequest,
    {},
    {},
    {}
  >({ url: "/v1/reminders", method: "post", ...variables, signal });

export const useCreateReminderV1RemindersPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ReminderWithPlantInfo,
      CreateReminderV1RemindersPostError,
      CreateReminderV1RemindersPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.ReminderWithPlantInfo,
    CreateReminderV1RemindersPostError,
    CreateReminderV1RemindersPostVariables
  >({
    mutationFn: (variables: CreateReminderV1RemindersPostVariables) =>
      fetchCreateReminderV1RemindersPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type DeleteReminderV1RemindersReminderIdDeletePathParams = {
  reminderId: string;
};

export type DeleteReminderV1RemindersReminderIdDeleteError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type DeleteReminderV1RemindersReminderIdDeleteVariables = {
  pathParams: DeleteReminderV1RemindersReminderIdDeletePathParams;
} & PlantsContext["fetcherOptions"];

export const fetchDeleteReminderV1RemindersReminderIdDelete = (
  variables: DeleteReminderV1RemindersReminderIdDeleteVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    void,
    DeleteReminderV1RemindersReminderIdDeleteError,
    undefined,
    {},
    {},
    DeleteReminderV1RemindersReminderIdDeletePathParams
  >({
    url: "/v1/reminders/{reminderId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteReminderV1RemindersReminderIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      DeleteReminderV1RemindersReminderIdDeleteError,
      DeleteReminderV1RemindersReminderIdDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    void,
    DeleteReminderV1RemindersReminderIdDeleteError,
    DeleteReminderV1RemindersReminderIdDeleteVariables
  >({
    mutationFn: (
      variables: DeleteReminderV1RemindersReminderIdDeleteVariables,
    ) =>
      fetchDeleteReminderV1RemindersReminderIdDelete({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type CompleteReminderV1RemindersReminderIdCompletePostPathParams = {
  reminderId: string;
};

export type CompleteReminderV1RemindersReminderIdCompletePostError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type CompleteReminderV1RemindersReminderIdCompletePostVariables = {
  pathParams: CompleteReminderV1RemindersReminderIdCompletePostPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchCompleteReminderV1RemindersReminderIdCompletePost = (
  variables: CompleteReminderV1RemindersReminderIdCompletePostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.ReminderWithPlantInfo,
    CompleteReminderV1RemindersReminderIdCompletePostError,
    undefined,
    {},
    {},
    CompleteReminderV1RemindersReminderIdCompletePostPathParams
  >({
    url: "/v1/reminders/{reminderId}/complete",
    method: "post",
    ...variables,
    signal,
  });

export const useCompleteReminderV1RemindersReminderIdCompletePost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ReminderWithPlantInfo,
      CompleteReminderV1RemindersReminderIdCompletePostError,
      CompleteReminderV1RemindersReminderIdCompletePostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.ReminderWithPlantInfo,
    CompleteReminderV1RemindersReminderIdCompletePostError,
    CompleteReminderV1RemindersReminderIdCompletePostVariables
  >({
    mutationFn: (
      variables: CompleteReminderV1RemindersReminderIdCompletePostVariables,
    ) =>
      fetchCompleteReminderV1RemindersReminderIdCompletePost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteCheckV1ChecksCheckIdDeletePathParams = {
  checkId: string;
};

export type DeleteCheckV1ChecksCheckIdDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeleteCheckV1ChecksCheckIdDeleteVariables = {
  pathParams: DeleteCheckV1ChecksCheckIdDeletePathParams;
} & PlantsContext["fetcherOptions"];

export const fetchDeleteCheckV1ChecksCheckIdDelete = (
  variables: DeleteCheckV1ChecksCheckIdDeleteVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    void,
    DeleteCheckV1ChecksCheckIdDeleteError,
    undefined,
    {},
    {},
    DeleteCheckV1ChecksCheckIdDeletePathParams
  >({ url: "/v1/checks/{checkId}", method: "delete", ...variables, signal });

export const useDeleteCheckV1ChecksCheckIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      DeleteCheckV1ChecksCheckIdDeleteError,
      DeleteCheckV1ChecksCheckIdDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    void,
    DeleteCheckV1ChecksCheckIdDeleteError,
    DeleteCheckV1ChecksCheckIdDeleteVariables
  >({
    mutationFn: (variables: DeleteCheckV1ChecksCheckIdDeleteVariables) =>
      fetchDeleteCheckV1ChecksCheckIdDelete({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeleteWateringV1WateringsWateringIdDeletePathParams = {
  wateringId: string;
};

export type DeleteWateringV1WateringsWateringIdDeleteError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type DeleteWateringV1WateringsWateringIdDeleteVariables = {
  pathParams: DeleteWateringV1WateringsWateringIdDeletePathParams;
} & PlantsContext["fetcherOptions"];

export const fetchDeleteWateringV1WateringsWateringIdDelete = (
  variables: DeleteWateringV1WateringsWateringIdDeleteVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    void,
    DeleteWateringV1WateringsWateringIdDeleteError,
    undefined,
    {},
    {},
    DeleteWateringV1WateringsWateringIdDeletePathParams
  >({
    url: "/v1/waterings/{wateringId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteWateringV1WateringsWateringIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      DeleteWateringV1WateringsWateringIdDeleteError,
      DeleteWateringV1WateringsWateringIdDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    void,
    DeleteWateringV1WateringsWateringIdDeleteError,
    DeleteWateringV1WateringsWateringIdDeleteVariables
  >({
    mutationFn: (
      variables: DeleteWateringV1WateringsWateringIdDeleteVariables,
    ) =>
      fetchDeleteWateringV1WateringsWateringIdDelete({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type CreatePhotoV1PhotosPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreatePhotoV1PhotosPostVariables = {
  body: Schemas.CreatePhotoRequest;
} & PlantsContext["fetcherOptions"];

export const fetchCreatePhotoV1PhotosPost = (
  variables: CreatePhotoV1PhotosPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.CreatePhotoResponseModel,
    CreatePhotoV1PhotosPostError,
    Schemas.CreatePhotoRequest,
    {},
    {},
    {}
  >({ url: "/v1/photos", method: "post", ...variables, signal });

export const useCreatePhotoV1PhotosPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CreatePhotoResponseModel,
      CreatePhotoV1PhotosPostError,
      CreatePhotoV1PhotosPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.CreatePhotoResponseModel,
    CreatePhotoV1PhotosPostError,
    CreatePhotoV1PhotosPostVariables
  >({
    mutationFn: (variables: CreatePhotoV1PhotosPostVariables) =>
      fetchCreatePhotoV1PhotosPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostPathParams = {
  photoId: string;
};

export type MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostVariables = {
  pathParams: MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchMarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPost = (
  variables: MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    void,
    MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostError,
    undefined,
    {},
    {},
    MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostPathParams
  >({
    url: "/v1/photos/{photoId}/mark_uploaded",
    method: "post",
    ...variables,
    signal,
  });

export const useMarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostError,
      MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    void,
    MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostError,
    MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostVariables
  >({
    mutationFn: (
      variables: MarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPostVariables,
    ) =>
      fetchMarkPhotoUploadedV1PhotosPhotoIdMarkUploadedPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostPathParams = {
  photoId: string;
};

export type MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostVariables = {
  pathParams: MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchMarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPost = (
  variables: MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    void,
    MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostError,
    undefined,
    {},
    {},
    MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostPathParams
  >({
    url: "/v1/photos/{photoId}/mark_cover_photo",
    method: "post",
    ...variables,
    signal,
  });

export const useMarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostError,
      MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    void,
    MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostError,
    MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostVariables
  >({
    mutationFn: (
      variables: MarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPostVariables,
    ) =>
      fetchMarkPhotoAsCoverPhotoV1PhotosPhotoIdMarkCoverPhotoPost({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type DeletePhotoV1PhotosPhotoIdDeletePathParams = {
  photoId: string;
};

export type DeletePhotoV1PhotosPhotoIdDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type DeletePhotoV1PhotosPhotoIdDeleteVariables = {
  pathParams: DeletePhotoV1PhotosPhotoIdDeletePathParams;
} & PlantsContext["fetcherOptions"];

export const fetchDeletePhotoV1PhotosPhotoIdDelete = (
  variables: DeletePhotoV1PhotosPhotoIdDeleteVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    void,
    DeletePhotoV1PhotosPhotoIdDeleteError,
    undefined,
    {},
    {},
    DeletePhotoV1PhotosPhotoIdDeletePathParams
  >({ url: "/v1/photos/{photoId}", method: "delete", ...variables, signal });

export const useDeletePhotoV1PhotosPhotoIdDelete = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      DeletePhotoV1PhotosPhotoIdDeleteError,
      DeletePhotoV1PhotosPhotoIdDeleteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    void,
    DeletePhotoV1PhotosPhotoIdDeleteError,
    DeletePhotoV1PhotosPhotoIdDeleteVariables
  >({
    mutationFn: (variables: DeletePhotoV1PhotosPhotoIdDeleteVariables) =>
      fetchDeletePhotoV1PhotosPhotoIdDelete({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type ListAllLocationsV1LocationsGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ListAllLocationsV1LocationsGetResponse = Schemas.Location[];

export type ListAllLocationsV1LocationsGetVariables =
  PlantsContext["fetcherOptions"];

export const fetchListAllLocationsV1LocationsGet = (
  variables: ListAllLocationsV1LocationsGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    ListAllLocationsV1LocationsGetResponse,
    ListAllLocationsV1LocationsGetError,
    undefined,
    {},
    {},
    {}
  >({ url: "/v1/locations", method: "get", ...variables, signal });

export const useListAllLocationsV1LocationsGet = <
  TData = ListAllLocationsV1LocationsGetResponse,
>(
  variables: ListAllLocationsV1LocationsGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListAllLocationsV1LocationsGetResponse,
      ListAllLocationsV1LocationsGetError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<
    ListAllLocationsV1LocationsGetResponse,
    ListAllLocationsV1LocationsGetError,
    TData
  >({
    queryKey: queryKeyFn({
      path: "/v1/locations",
      operationId: "listAllLocationsV1LocationsGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchListAllLocationsV1LocationsGet(
        { ...fetcherOptions, ...variables },
        signal,
      ),
    ...options,
    ...queryOptions,
  });
};

export type CreateLocationV1LocationsPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type CreateLocationV1LocationsPostVariables = {
  body: Schemas.CreateLocationRequest;
} & PlantsContext["fetcherOptions"];

export const fetchCreateLocationV1LocationsPost = (
  variables: CreateLocationV1LocationsPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.Location,
    CreateLocationV1LocationsPostError,
    Schemas.CreateLocationRequest,
    {},
    {},
    {}
  >({ url: "/v1/locations", method: "post", ...variables, signal });

export const useCreateLocationV1LocationsPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Location,
      CreateLocationV1LocationsPostError,
      CreateLocationV1LocationsPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.Location,
    CreateLocationV1LocationsPostError,
    CreateLocationV1LocationsPostVariables
  >({
    mutationFn: (variables: CreateLocationV1LocationsPostVariables) =>
      fetchCreateLocationV1LocationsPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type UpdateLocationV1LocationsLocationIdPatchPathParams = {
  locationId: string;
};

export type UpdateLocationV1LocationsLocationIdPatchError =
  Fetcher.ErrorWrapper<
    | {
        status: 401;
        payload: Schemas.UnauthorizedResponse;
      }
    | {
        status: 422;
        payload: Schemas.HTTPValidationError;
      }
  >;

export type UpdateLocationV1LocationsLocationIdPatchVariables = {
  body: Schemas.CreateLocationRequest;
  pathParams: UpdateLocationV1LocationsLocationIdPatchPathParams;
} & PlantsContext["fetcherOptions"];

export const fetchUpdateLocationV1LocationsLocationIdPatch = (
  variables: UpdateLocationV1LocationsLocationIdPatchVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.Location,
    UpdateLocationV1LocationsLocationIdPatchError,
    Schemas.CreateLocationRequest,
    {},
    {},
    UpdateLocationV1LocationsLocationIdPatchPathParams
  >({
    url: "/v1/locations/{locationId}",
    method: "patch",
    ...variables,
    signal,
  });

export const useUpdateLocationV1LocationsLocationIdPatch = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Location,
      UpdateLocationV1LocationsLocationIdPatchError,
      UpdateLocationV1LocationsLocationIdPatchVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.Location,
    UpdateLocationV1LocationsLocationIdPatchError,
    UpdateLocationV1LocationsLocationIdPatchVariables
  >({
    mutationFn: (
      variables: UpdateLocationV1LocationsLocationIdPatchVariables,
    ) =>
      fetchUpdateLocationV1LocationsLocationIdPatch({
        ...fetcherOptions,
        ...variables,
      }),
    ...options,
  });
};

export type LambdaHealthGetError = Fetcher.ErrorWrapper<undefined>;

export type LambdaHealthGetVariables = PlantsContext["fetcherOptions"];

export const fetchLambdaHealthGet = (
  variables: LambdaHealthGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<void, LambdaHealthGetError, undefined, {}, {}, {}>({
    url: "/health",
    method: "get",
    ...variables,
    signal,
  });

export const useLambdaHealthGet = <TData = void,>(
  variables: LambdaHealthGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, LambdaHealthGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<void, LambdaHealthGetError, TData>({
    queryKey: queryKeyFn({
      path: "/health",
      operationId: "lambdaHealthGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchLambdaHealthGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type LoginAuthTokenPostError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type LoginAuthTokenPostVariables = {
  body: Schemas.LoginRequest;
} & PlantsContext["fetcherOptions"];

export const fetchLoginAuthTokenPost = (
  variables: LoginAuthTokenPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.TokenResponse,
    LoginAuthTokenPostError,
    Schemas.LoginRequest,
    {},
    {},
    {}
  >({ url: "/auth/token", method: "post", ...variables, signal });

export const useLoginAuthTokenPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenResponse,
      LoginAuthTokenPostError,
      LoginAuthTokenPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.TokenResponse,
    LoginAuthTokenPostError,
    LoginAuthTokenPostVariables
  >({
    mutationFn: (variables: LoginAuthTokenPostVariables) =>
      fetchLoginAuthTokenPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type LogoutAuthLogoutPostError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: Schemas.UnauthorizedResponse;
}>;

export type LogoutAuthLogoutPostVariables = PlantsContext["fetcherOptions"];

export const fetchLogoutAuthLogoutPost = (
  variables: LogoutAuthLogoutPostVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<
    Schemas.LogoutResponse,
    LogoutAuthLogoutPostError,
    undefined,
    {},
    {},
    {}
  >({ url: "/auth/logout", method: "post", ...variables, signal });

export const useLogoutAuthLogoutPost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LogoutResponse,
      LogoutAuthLogoutPostError,
      LogoutAuthLogoutPostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = usePlantsContext();
  return reactQuery.useMutation<
    Schemas.LogoutResponse,
    LogoutAuthLogoutPostError,
    LogoutAuthLogoutPostVariables
  >({
    mutationFn: (variables: LogoutAuthLogoutPostVariables) =>
      fetchLogoutAuthLogoutPost({ ...fetcherOptions, ...variables }),
    ...options,
  });
};

export type ReadUsersMeAuthMeGetError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: Schemas.UnauthorizedResponse;
    }
  | {
      status: 422;
      payload: Schemas.HTTPValidationError;
    }
>;

export type ReadUsersMeAuthMeGetVariables = PlantsContext["fetcherOptions"];

export const fetchReadUsersMeAuthMeGet = (
  variables: ReadUsersMeAuthMeGetVariables,
  signal?: AbortSignal,
) =>
  plantsFetch<Schemas.User, ReadUsersMeAuthMeGetError, undefined, {}, {}, {}>({
    url: "/auth/me",
    method: "get",
    ...variables,
    signal,
  });

export const useReadUsersMeAuthMeGet = <TData = Schemas.User,>(
  variables: ReadUsersMeAuthMeGetVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.User, ReadUsersMeAuthMeGetError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    usePlantsContext(options);
  return reactQuery.useQuery<Schemas.User, ReadUsersMeAuthMeGetError, TData>({
    queryKey: queryKeyFn({
      path: "/auth/me",
      operationId: "readUsersMeAuthMeGet",
      variables,
    }),
    queryFn: ({ signal }) =>
      fetchReadUsersMeAuthMeGet({ ...fetcherOptions, ...variables }, signal),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/v1/plants";
      operationId: "listAllPlantsV1PlantsGet";
      variables: ListAllPlantsV1PlantsGetVariables;
    }
  | {
      path: "/v1/plants/{plantId}";
      operationId: "getPlantV1PlantsPlantIdGet";
      variables: GetPlantV1PlantsPlantIdGetVariables;
    }
  | {
      path: "/v1/plants/{plantId}/photos";
      operationId: "getPlantPhotosV1PlantsPlantIdPhotosGet";
      variables: GetPlantPhotosV1PlantsPlantIdPhotosGetVariables;
    }
  | {
      path: "/v1/reminders/outstanding";
      operationId: "getOutstandingRemindersV1RemindersOutstandingGet";
      variables: GetOutstandingRemindersV1RemindersOutstandingGetVariables;
    }
  | {
      path: "/v1/locations";
      operationId: "listAllLocationsV1LocationsGet";
      variables: ListAllLocationsV1LocationsGetVariables;
    }
  | {
      path: "/health";
      operationId: "lambdaHealthGet";
      variables: LambdaHealthGetVariables;
    }
  | {
      path: "/auth/me";
      operationId: "readUsersMeAuthMeGet";
      variables: ReadUsersMeAuthMeGetVariables;
    };
